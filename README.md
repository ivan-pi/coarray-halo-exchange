## Parallel Halo Exchange Using Fortran Coarrays

This repository contains code and test cases for investigating Fortran
coarray implementations of a parallel halo exchange operation associated
with domain decomposition methods for PDE. Here the domain is partitioned
into *P* subdomains, one for each of *P* processes (or images), and each
process calculates the unknown variables defined on its subdomain.
Processes need to exchange values along their subdomain boundary with
their neighbors in a *halo exchange* operation.

### Background
The particular form of the halo exchange considered here originates from the
MPI-parallel code [Truchas](https://gitlab.com/truchas/truchas). Abstractly
one starts with a (global) index set {1, 2, ..., *N*}. Given *P* processes,
an index is assigned to a unique process according to a block partition of
the index set: the first *N1* indices are assigned to process 1, the next
*N2* to process 2, etc. An index so assigned to a process is said to be
*owned* by that process. In addition to these, a process may include indices
owned by other processes. The owned indices are said to be *on-process* and
these additional indices, if any, are said to be *off-process*. For the
purposes of computation, the collection of all indices known to a process
are mapped to a process-local index set: the block of on-process indices are
mapped, in order, to consecutive local indices starting at 1, and the
off-process indices are mapped to consecutive local indices immediately
following these.

Now the elements of an array indexed by this index set will be distributed
across the *P* processes according to the distribution of the indices.
Each global index is owned by exactly one process (where it is on-process)
but may exist on other processes as an off-process index. The mapping from
off-process indices to their corresponding on-process index is a many-to-one
mapping. A fundamental operation on the distributed array is to replace the
value at each off-process index with the value at its corresponding
on-process index; this is referred to as a *gather* (of off-process data)
operation.

This distributed index set mapping and the associated gather operation
are implemented by the module [`index_map_type.F90`](index_map_type.f90).

### The Tests
The file [`main.f90`](main.f90) is a test driver. It reads data that
describes the partitioning of the index set and then performs the gather
operation on an integer array. The on-process elements of the array are
initialized with their corresponding global IDs and the off-process elements
with invalid data (-1). After the gather operation the off-process elements
should be filled with their global IDs, and this is checked. To get more
accurate timings the gather operation may be repeated multiple times.

The test data is stored in subdirectories of the `test-data` directory,
one for each test. A subdirectory contains a collection of input files,
one per image. Each file (unformatted stream) consists of 2 records. The
first consists of the block size assigned to the image (i.e., the number
of on-process indices) and the number of off-process indices. The second
record is the global IDs of the off-process indices in strictly increasing
order.

The current test data was generated by a version of Truchas hacked to output
this internal data. It comes from an unstructured finite element type mesh
partitioned using METIS and corresponds to the cell index set (there are
also the node, face, and edge index sets that could be obtained). There is
data from a series of meshes ("opencalc-B") of increasing size:

  | Mesh | B0  | B1   | B2   | B3   | B4
  | ---- | --  | --   | --   | --   | --
  | Cells| 70K | 206K | 562K | 1.6M | 4.4M

Each mesh is partitioned into various numbers of partitions. The mesh and
number of partitions is reflected in the name of the test subdirectory.

The test executable takes 1 or 2 command line arguments. The first is the
path to the directory containing the data files for the test. The second
is the number of times to repeat the gather operation before collecting
timing data. If not specified it defaults to just 1. Only the gather
operation itself is timed.

Here is a summary of how to compile and run the tests for different
compilers:

* **ifort:** Intel Fortran and MPI 2021.4.0
  - `ifort -coarray -O3 index_map_type.f90 main.f90`
  - `export FOR_COARRAY_NUM_IMAGES=12`
  - `./a.out <arguments>`
* **gfortran:** GCC 11.2.0, MPICH 3.3.2, OpenCoarrays 2.9.2-13-g235167d
  - `caf -O3 index_map_type.f90 main.f90`
  - `cafrun -n 12 ./a.out <arguments>`
* **nagfor:** NAG Fortran 7.1.7103
  - `nagfor -coarray -O3 -f2018 index_map_type.F90 main.f90`
  - `export NAGFOR_NUM_IMAGES=12`
  - `./a.out <arguments>`

### Results
#### 20 Jan 2022

These were collected using a 12-core AMD Threadripper 2920X CPU.

test-#image | ifort | gfortran | nagfor
---------- | ----- | -------- | ------
B0-12 | 0.37 s | 0.033 s | 0.000034 s
B1-12 | 0.89 s | 0.061 s | 0.000044 s
B2-12 | 2.1 s  | 0.12 s  | 0.000057 s
B3-12 | 8.9 s  | 0.29 s  | 0.000086 s
B4-12 | 34 s   | 0.45 s  | 0.00032 s

Note: Intel misidentifies the layout of this processor as 6-cores with
4 hardware threads per core. I used

    export I_MPI_PIN_PROCESSOR_LIST=0-11

which appears to properly assign processes to cores (up to 12 processes).
However it made little actual difference in the ultimate timings.
