## Parallel Halo Exchange Using Fortran Coarrays

This repository contains code and test cases for investigating Fortran
coarray implementations of a parallel halo exchange operation associated
with domain decomposition methods for PDE. Here the domain is partitioned
into *P* subdomains, one for each of *P* processes (or images), and each
process calculates the unknown variables defined on its subdomain.
Processes need to exchange values along their subdomain boundary with
their neighbors in a *halo exchange* operation.

>I'd very much welcome receiving results from different platforms and/or
compilers than those given below. There is test data for a quite a few
different numbers of images/process, and I can generate others if asked.
I also welcome comments on the code, and other coarray approaches that
might be more efficient. If you have any thoughts on why Intel performs
so poorly, I'd especially like to hear those.

### Background
The particular form of the halo exchange considered here originates from the
MPI-parallel code [Truchas](https://gitlab.com/truchas/truchas). Abstractly
one starts with a (global) index set {1, 2, ..., *N*}. Given *P* processes,
an index is assigned to a unique process according to a block partition of
the index set: the first *N1* indices are assigned to process 1, the next
*N2* to process 2, etc. An index so assigned to a process is said to be
*owned* by that process. In addition to these, a process may include indices
owned by other processes. The owned indices are said to be *on-process* and
these additional indices, if any, are said to be *off-process*. For the
purposes of computation, the collection of all indices known to a process
are mapped to a process-local index set: the block of on-process indices are
mapped, in order, to consecutive local indices starting at 1, and the
off-process indices are mapped to consecutive local indices immediately
following these.

Now the elements of an array indexed by this index set will be distributed
across the *P* processes according to the distribution of the indices.
Each global index is owned by exactly one process (where it is on-process)
but may exist on other processes as an off-process index. The mapping from
off-process indices to their corresponding on-process index is a many-to-one
mapping. A fundamental operation on the distributed array is to replace the
value at each off-process index with the value at its corresponding
on-process index; this is referred to as a *gather* (of off-process data)
operation.

### Coarray Implementations
In the gather (or halo exchange) operation each image sends some elements
of its on-process data to other images, where it is received to overwrite
off-process data, and likewise receives on-process data from other images
to overwrite its own off-process data. There are 4 different coarray
implementations of this operation. They all perform exactly the same data
exchange, but differ only in how it is organized.

* **Scattered read from remote image (version 1):**
Each image reads indirectly-indexed on-process data from remote images
to fill its (contiguous) array of off-process data
* **Blocked-read from remote image (version 2):**
Each image pre-gathers its on-process data destined for other images into
contiguous blocks of a send buffer, and then each image reads its buffer
blocks from remote images to fill corresponding blocks of its off-process
data array.
* **Gathered write to remote image (version 3):**
Each image writes its indirectly indexed on-process data to (contiguous)
blocks of remote images off-process data.
* **Blocked-write to remote image (version 4):**
Each image pre-gathers its on-process data destined for other images into
contiguous blocks of a send buffer, and then writes those blocks to
corresponding blocks of remote image off-process data arrays.

Version 1 is the most straightforward and simple implementation. The other
versions were intended to explore whether there is a performance preference
between reading from or writing to remote images, and whether performance
gains could be made by structuring the transfers to/from remote images in
contiguous blocks of data.

The distributed index set mapping and the associated gather operation
are implemented by the module `index_map_type.f90` found in the subdirectories
`coarray1`, `coarray2`, `coarray3`, and `coarray4` for each of the different
versions. The gather operation is performed by the module procedure
`gather_aux`, and the configuration of the communication pattern used by
that procedure is generated by the module procedure `add_offp_index`.

### Reference MPI Implementation

An MPI implementation of the halo exchange is found in the `mpi` and `mpi_f08`
directories. (The only difference between the two is whether the `mpi` or
`mpi_f08` module is used.) This serves as a baseline against which to assess
the different coarray implementations. It uses a graph communicator and MPI-3
neighborhood collective to perform the halo exchange.

### The Tests
The file `main.f90` is a test driver. It reads data that
describes the partitioning of the index set and then performs the gather
operation on an integer array. The on-process elements of the array are
initialized with their corresponding global IDs and the off-process elements
with invalid data (-1). After the gather operation the off-process elements
should be filled with their global IDs, and this is checked. To get more
accurate timings the gather operation may be repeated multiple times.

The test data is stored in subdirectories of the `test-data` directory,
one for each test. A subdirectory contains a collection of input files,
one per image. Each file (unformatted stream) consists of 2 records. The
first consists of the block size assigned to the image (i.e., the number
of on-process indices) and the number of off-process indices. The second
record is the global IDs of the off-process indices in strictly increasing
order.

The current test data was generated by a version of Truchas hacked to output
this internal data. It comes from an unstructured finite element type mesh
partitioned using METIS and corresponds to the cell index set (there are
also the node, face, and edge index sets that could be obtained). There is
data from a series of meshes ("opencalc-B") of increasing size:

  | Mesh | B0  | B1   | B2   | B3   | B4
  | ---- | --  | --   | --   | --   | --
  | Cells| 70K | 206K | 562K | 1.6M | 4.4M

Each mesh is partitioned into various numbers of partitions. The mesh and
number of partitions is reflected in the name of the test subdirectory.

The test executable takes 1 or 2 command line arguments. The first is the
path to the directory containing the data files for the test. The second
is the number of times to repeat the gather operation before collecting
timing data. If not specified it defaults to just 1. Only the gather
operation itself is timed.

Here is a summary of how to compile and run the tests for different
compilers; your details may differ somewhat:

* Coarray tests:
  * Intel:
    - `ifort -coarray -O3 coarray_collectives.f90 index_map_type.f90 main.f90`
    - `export FOR_COARRAY_NUM_IMAGES=12`
    - `./a.out <test arguments>`
    - See [INTEL-ISSUES.md](INTEL-ISSUES.md) for problems you may encounter and their solution. 
  * GNU Fortran / OpenCoarrays:
    - `caf -O3 coarray_collectives.f90 index_map_type.f90 main.f90`
    - `cafrun -n 12 ./a.out <test arguments>`
  * NAG:
    - `nagfor -coarray -O3 -f2018 coarray_collectives.f90 index_map_type.f90 main.f90`
    - `export NAGFORTRAN_NUM_IMAGES=12`
    - `./a.out <test arguments>`
* MPI tests:
  * Intel:
    - `mpifc -O3 index_map_type.f90 main.f90`
    - `mpirun -np 12 ./a.out <test arguments>`
  * NAG and GNU Fortran (with MPICH):
    - `mpifort -O3 index_map_type.f90 main.f90`
    - `mpirun -np 12 ./a.out <test arguments>`

### Results
* [Linux / 12-core Threadripper 2920X / 12 images](results/thelio-12.md)
* [Variations of version1](results/thelio-12-v1-variations.md); NAG beats MPI
